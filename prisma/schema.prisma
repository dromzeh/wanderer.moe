// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

generator client {
  provider = "prisma-client-js"
}

// auth tables
model AuthUser {
  id                   String              @id @unique
  auth_session         AuthSession[]
  auth_key             AuthKey[]
  avatar_url           String? // TODO: create a default avatar on the CDN
  banner_url           String?
  username             String              @unique
  username_colour      String?
  email                String              @unique
  email_verified       Int                 @default(0)
  pronouns             String?
  verified             Int                 @default(0)
  bio                  String              @default("")
  assets               Assets[]
  date_joined          DateTime            @default(now())
  roles                Role[]
  self_assignable_tags SelfAssignableTag[]
  connections          Connection[]

  // relations
  followers Follower[]
  following Following[]

  @@map("auth_user")
}

model AuthSession {
  id             String   @id @unique
  user_id        String
  active_expires BigInt
  idle_expires   BigInt
  auth_user      AuthUser @relation(references: [id], fields: [user_id], onDelete: Cascade)

  @@index([user_id])
  @@map("auth_session")
}

model AuthKey {
  id              String   @id @unique
  hashed_password String?
  user_id         String
  primary_key     Boolean
  expires         BigInt?
  auth_user       AuthUser @relation(references: [id], fields: [user_id], onDelete: Cascade)

  @@index([user_id])
  @@map("auth_key")
}

model Follower {
  id       String   @id @unique
  user_id  String
  follower AuthUser @relation(references: [id], fields: [user_id], onDelete: Cascade)

  @@index([user_id])
  @@map("follower")
}

model Following {
  id        String   @id @unique
  user_id   String
  following AuthUser @relation(references: [id], fields: [user_id], onDelete: Cascade)

  @@index([user_id])
  @@map("following")
}

model SelfAssignableTag {
  id        Int      @id @default(autoincrement())
  name      String
  auth_user AuthUser @relation(references: [id], fields: [user_id], onDelete: Cascade)
  user_id   String

  @@index([user_id])
  @@map("self_assignable_tag")
}

model Role {
  id        Int      @id @default(autoincrement())
  name      String
  auth_user AuthUser @relation(references: [id], fields: [user_id], onDelete: Cascade)
  user_id   String

  @@index([user_id])
  @@map("role")
}

model Connection {
  id        Int      @id @default(autoincrement())
  auth_user AuthUser @relation(references: [id], fields: [user_id], onDelete: Cascade)
  user_id   String
  address   String

  @@index([user_id])
  @@map("connection")
}

model Games {
  id               Int    @id @default(autoincrement())
  name             String
  asset_categories String

  @@index([id])
}

model OC_Generators {
  game          String            @id
  data          String
  uploaded_by   String            @default("System") // OC Generators will never be added by any users, but i'm appending uploaded_by for consistency
  uploaded_date String
  status        OCGeneratorStatus @default(pending)
  view_count    Int               @default(0)

  @@index([game])
}

model Assets {
  id             Int            @id @default(autoincrement())
  name           String
  game           String
  asset          String
  tags           AssetTagsNames @default(official)
  url            String
  status         AssetStatus    @default(pending)
  auth_user      AuthUser       @relation(references: [id], fields: [uploaded_by])
  userId         String
  uploaded_by    String
  uploaded_date  String
  view_count     Int            @default(0)
  download_count Int            @default(0)
  file_size      Int

  @@index([id])
  @@index([uploaded_by])
}

model AssetCategories {
  id   Int    @id @default(autoincrement())
  name String

  @@index([id])
}

// role & tag enums
enum RoleNames {
  user
  plus
  translator
  staff
  developer
  creator
}

enum SelfAssignTagsNames {
  designer
  developer
  artist
  writer
  musician
  content_creator
}

enum AssetTagsNames {
  official
  fanmade
}

// status enums
enum AssetStatus {
  pending
  approved
  rejected
}

enum OCGeneratorStatus {
  pending
  approved
  rejected
}
